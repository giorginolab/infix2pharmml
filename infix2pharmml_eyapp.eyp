# -*- antlr -*-

%token NAN = /\b(nan|NaN|notanumber)\b/
%token EULER = /\b(e|exponentiale)\b/
%token PI = /\b(pi)\b/
%token INF = /\b(inf|infinity)\b/

%token NUM = /([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)/
%token VAR = /([A-Za-z][A-Za-z0-9_]*)/


# Probably can be greatly simplified bc. of automatic precedence assignments

%right  '='
%left   '-' '+'
%left   '*' '/' 
%right  '^'
%left   NEG

%%
start:          statement 
    ;

statement:      VAR ':=' equation        {infix2pharmml::vardef($_[1],$_[3])}
              | VAR '=' equation         {infix2pharmml::varass($_[1],$_[3])}
              | 'diff(' VAR ',' VAR ')=' equation
                                         {infix2pharmml::diff($_[2],$_[4],$_[6])}
              | VAR '(' varlist '):=' equation 
                                         {infix2pharmml::funcdef($_[1],$_[3],$_[5])}
              | equation    
    ;           

equation:       expression               {infix2pharmml::eqn($_[1])}
    ;

expression:     expression '+' term      {infix2pharmml::b("plus", $_[1], $_[3])}
              | expression '-' term      {infix2pharmml::b("minus",$_[1], $_[3])}
              | term      
    ;

term:           term '*' power           {infix2pharmml::b("times", $_[1], $_[3])}
              | term '/' power           {infix2pharmml::b("divide",$_[1], $_[3])}
              | power
    ;

power:          factor '^' power        {infix2pharmml::b("power", $_[1], $_[3])}
              | factor
    ;

factor:         NUM                      {infix2pharmml::e("ct:Real",$_[1])}
              | constant                 {infix2pharmml::const($_[1])}
              | factor '!'               {infix2pharmml::u("factorial",$_[1])}
              | '+' factor               {$_[2]}
              | '-' factor %prec NEG     {infix2pharmml::u("minus",$_[2])}
              | '(' expression ')'       {$_[2]}
              | uniop '(' expression ')' {infix2pharmml::u($_[1],$_[3])}
              | binop '(' expression ',' expression ')' 
                                         {infix2pharmml::b($_[1],$_[3],$_[5])}
              | VAR '(' argpairlist ')'  {infix2pharmml::fc($_[1],$_[3])}
              | VAR                      {infix2pharmml::symbref($_[1])}
    ;


# page 245 spec. 0.2.1 + addenda

uniop:  'exp' | 'log' | 'minus' | 'factorial' | 'sin' | 'cos' | 'tan' |
        'sec' | 'csc' | 'cot' | 'sinh' | 'cosh' | 'tanh' | 'sech' |
        'csch' | 'coth' | 'arcsin' | 'arccos' | 'arctan' | 'arcsec' |
        'arccsc' | 'arccot' | 'arcsinh' | 'arccosh' | 'arctanh' |
        'arcsech' | 'arccsch' | 'arccoth' | 'floor' | 'ceiling' |
        'abs' | 'logistic' | 'logit' | 'probit' 
      | 'ln' | 'factln' | 'gammaln' | 'normcdf' | 'sqrt' 

    ;

binop:          'atan2' | 'logx' | 'min' | 'max' | 'root'
    ;

constant:     NAN          {"notanumber"}
            | PI           {"pi"}
            | EULER        {"exponentiale"}
            | INF          {"infinity"}
    ;


argpair:        VAR '=' equation       {infix2pharmml::fa($_[1],$_[3]) } 
    ;                                  

argpairlist:    argpair ',' argpairlist  { $_[1].$_[3] }
              | argpair
    ;

varlist:        VAR ',' varlist  {infix2pharmml::funcarg($_[1]).$_[3] }
              | VAR              {infix2pharmml::funcarg($_[1])}
    ;

%%
