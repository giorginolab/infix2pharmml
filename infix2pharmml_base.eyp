# -*- antlr -*-

%token NAN = /\b(nan|NaN|notanumber)\b/
%token EULER = /\b(e|exponentiale)\b/
%token PI = /\b(pi)\b/
%token INF = /\b(inf|infinity)\b/

%token UNIOP = /\b(exp|log|minus|factorial|sin|cos|tan|sec|csc|cot|sinh|cosh|tanh|sech|csch|coth|arcsin|arccos|arctan|arcsec|arccsc|arccot|arcsinh|arccosh|arctanh|arcsech|arccsch|arccoth|floor|ceiling|abs|logistic|logit|probit|ln|factln|gammaln|normcdf|sqrt|heaviside|sign)\b/

%token BINOP = /\b(atan2|logx|min|max|root|rem)\b/

%token MACRO = /\b(Absorption|Compartment|Depot|Effect|Elimination|IV|Oral|Peripheral|Transfer)\b/

%token PAR = /\b(par)\b/

%token NUM = /([+-]?[0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)/
%token VAR = /([A-Za-z][A-Za-z0-9_]*)/

%token COMMENT = /#(.*)/
%token DESCRIPTION = /\{(.+?)\}/


%left   ','
%right  '='
%left   '-' '+'
%left   '*' '/' 
%right  '^'
%left   '!'
%left   NEG

/* The word "STARTRULE" below will be replaced by Makefile to make two similar grammars
 * STARTRULE->{statement,model}
 */
%start STARTRULE

%%

model: 
        line +
    ;


/* Don't remember the reason why I wanted comments in the grammar */
line:
      COMMENT
    | assignment ';' ? COMMENT ? 
    ;

/* Things allowed in model (stand-alone) mode. We can't allow function definitions because they would their own variable scope. */
assignment:  
      common
    | MACRO '(' macroargpairlist ')'       {infix2pharmml::macro($_[1],$_[3])}
    | PAR parameterlist 
    ;


macroargpairlist:    
      macroargpairlist ',' macroargpairlist     {$_[1].$_[3]}
    | expr                                  {infix2pharmml::macroarg($_[1]) } 
    | VAR '=' expr                          {infix2pharmml::macroarg($_[1],$_[3]) } 
    ;


/* For reasons unknown this should precede "expr" for the VAR = NUM form to match */
parameterlist:
      parameterlist ',' parameterlist           {$_[1].$_[3]}
    | VAR '=' NUM                               {infix2pharmml::par_n($_[1],$_[3])}
    | VAR '=' expr                          {infix2pharmml::par($_[1],$_[3])}
    ;




/* Things only allowed in statement mode */
statement:
      common
    | expr    
    | VAR '=' expr                   {infix2pharmml::varass($_[1],$_[3])}
    | VAR '(' varlist '):=' expr     {infix2pharmml::funcdef($_[1],$_[3],$_[5])}
    ;           

varlist:        varlist ',' varlist  {$_[1].$_[3]}
              | VAR                  {infix2pharmml::funcarg($_[1])}
    ;






/* Things in both grammars */
common:
      VAR ':=' expr  DESCRIPTION ?          {infix2pharmml::vardef($_[1],$_[3],$_[4])}
    | 'diff(' VAR ',' VAR ')=' expr  DESCRIPTION ?
                                                {infix2pharmml::diff($_[2],$_[4],$_[6],$_[7])}
    | 'diff(' VAR ',' VAR '):=' expr DESCRIPTION ?
                                                {infix2pharmml::diff($_[2],$_[4],$_[6],$_[7])}
    ;





expr:   
      expr '+' expr                      {infix2pharmml::b("plus",  $_[1], $_[3])}
    | expr '-' expr                      {infix2pharmml::b("minus", $_[1], $_[3])}
    | expr '*' expr                      {infix2pharmml::b("times", $_[1], $_[3])}
    | expr '/' expr                      {infix2pharmml::b("divide",$_[1], $_[3])}
    | expr '^' expr                      {infix2pharmml::b("power", $_[1], $_[3])}
    | NUM                                {infix2pharmml::e("ct:Real",$_[1])}
    | constant                           {infix2pharmml::const($_[1])}
    | expr '!'                           {infix2pharmml::u("factorial",$_[1])}
    | '-' expr %prec NEG                 {infix2pharmml::u("minus",$_[2])}
    | '(' expr ')'                       {$_[2]}
    | UNIOP '(' expr ')'                 {infix2pharmml::u($_[1],$_[3])}
    | BINOP '(' expr ',' expr ')'        {infix2pharmml::b($_[1],$_[3],$_[5])}
    | 'delay' '(' VAR.v ',' VAR.d ')'    {infix2pharmml::delay($v,$d)}
    | VAR '(' argpairlist ')'            {infix2pharmml::fc($_[1],$_[3])}
    | VAR                                {infix2pharmml::symbref($_[1])}
    ;


/* page 245 spec. 0.2.1 + addenda */



constant:     NAN          {"notanumber"}
            | PI           {"pi"}
            | EULER        {"exponentiale"}
            | INF          {"infinity"}
    ;


argpairlist:    argpairlist ',' argpairlist  { $_[1].$_[3] }
              | VAR '=' expr             {infix2pharmml::fa($_[1],$_[3]) } 
    ;





%%
