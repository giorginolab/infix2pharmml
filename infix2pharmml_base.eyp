# -*- antlr -*-

%token NAN = /\b(nan|NaN|notanumber)\b/
%token EULER = /\b(e|exponentiale)\b/
%token PI = /\b(pi)\b/
%token INF = /\b(inf|infinity)\b/

%token UNIOP = /\b(exp|log|minus|factorial|sin|cos|tan|sec|csc|cot|sinh|cosh|tanh|sech|csch|coth|arcsin|arccos|arctan|arcsec|arccsc|arccot|arcsinh|arccosh|arctanh|arcsech|arccsch|arccoth|floor|ceiling|abs|logistic|logit|probit|ln|factln|gammaln|normcdf|sqrt)\b/

%token BINOP = /\b(atan2|logx|min|max|root|rem)\b/

%token MACRO = /\b(Absorption|Compartment|Depot|Effect|Elimination|IV|Oral|Peripheral|Transfer)\b/
    
%token NUM = /([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)/
%token VAR = /([A-Za-z][A-Za-z0-9_]*)/

%token DESCRIPTION = /{(.+?)}/


%left   ','
%right  '='
%left   '-' '+'
%left   '*' '/' 
%right  '^'
%left   '!'
%left   NEG

# The word "START RULE" below will be replaced by Makefile to make two similar grammars
%start STARTRULE

%%

model:
      model line
    | line
    ;

line:
     structuralstmt ';' ?
    ;


structuralstmt:  
      VAR ':=' equation  DESCRIPTION ?  
                                           {infix2pharmml::vardef($_[1],$_[3],$_[4])}
    | 'diff(' VAR ',' VAR ')=' equation  DESCRIPTION ?
                                           {infix2pharmml::diff($_[2],$_[4],$_[6],$_[7])}
    | 'diff(' VAR ',' VAR '):=' equation DESCRIPTION ?
                                           {infix2pharmml::diff($_[2],$_[4],$_[6],$_[7])}
    | MACRO '(' macroargpairlist ')' 
                                           {infix2pharmml::macro($_[1],$_[3])}
    | 'par' parlist 
    ;



macroargpairlist:    
      macroargpairlist ',' macroargpairlist  
                                         {$_[1].$_[3]}
    | equation                 {infix2pharmml::macroarg($_[1]) } 
    | VAR '=' equation         {infix2pharmml::macroarg($_[1],$_[3]) } 
    ;


parlist:
      parlist ',' parlist      {$_[1].$_[3]}
    | VAR '=' equation         {infix2pharmml::par($_[1],$_[3])}
    ;

statement:
      VAR ':=' equation                  {infix2pharmml::vardef($_[1],$_[3])}
    | VAR '=' equation                   {infix2pharmml::varass($_[1],$_[3])}
    | 'diff(' VAR ',' VAR ')=' equation
                                         {infix2pharmml::diff($_[2],$_[4],$_[6])}
    | 'diff(' VAR ',' VAR '):=' equation
                                         {infix2pharmml::diff($_[2],$_[4],$_[6])}
    | VAR '(' varlist '):=' equation 
                                         {infix2pharmml::funcdef($_[1],$_[3],$_[5])}
    | equation    
    ;           

equation:       expr                     {infix2pharmml::eqn($_[1])}
    ;

expr:   
      expr '+' expr                      {infix2pharmml::b("plus",  $_[1], $_[3])}
    | expr '-' expr                      {infix2pharmml::b("minus", $_[1], $_[3])}
    | expr '*' expr                      {infix2pharmml::b("times", $_[1], $_[3])}
    | expr '/' expr                      {infix2pharmml::b("divide",$_[1], $_[3])}
    | expr '^' expr                      {infix2pharmml::b("power", $_[1], $_[3])}
    | NUM                                {infix2pharmml::e("ct:Real",$_[1])}
    | constant                           {infix2pharmml::const($_[1])}
    | expr '!'                           {infix2pharmml::u("factorial",$_[1])}
    | '+' expr                           {$_[2]}
    | '-' expr %prec NEG                 {infix2pharmml::u("minus",$_[2])}
    | '(' expr ')'                       {$_[2]}
    | UNIOP '(' expr ')'                 {infix2pharmml::u($_[1],$_[3])}
    | BINOP '(' expr ',' expr ')'        {infix2pharmml::b($_[1],$_[3],$_[5])}
    | VAR '(' argpairlist ')'            {infix2pharmml::fc($_[1],$_[3])}
    | VAR                                {infix2pharmml::symbref($_[1])}
    ;


# page 245 spec. 0.2.1 + addenda



constant:     NAN          {"notanumber"}
            | PI           {"pi"}
            | EULER        {"exponentiale"}
            | INF          {"infinity"}
    ;


argpairlist:    argpairlist ',' argpairlist  { $_[1].$_[3] }
              | VAR '=' equation             {infix2pharmml::fa($_[1],$_[3]) } 
    ;


varlist:        varlist ',' varlist  {$_[1].$_[3]}
              | VAR                  {infix2pharmml::funcarg($_[1])}
    ;

%%
